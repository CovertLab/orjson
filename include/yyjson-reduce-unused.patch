diff --git a/include/yyjson/yyjson.c b/include/yyjson/yyjson.c
index fc80574..803c2f5 100644
--- a/include/yyjson/yyjson.c
+++ b/include/yyjson/yyjson.c
@@ -3997,8 +3986,7 @@ static_inline bool is_truncated_str(u8 *cur, u8 *end,
  Returns true if the input is valid but truncated.
  */
 static_noinline bool is_truncated_end(u8 *hdr, u8 *cur, u8 *end,
-                                      yyjson_read_code code,
-                                      yyjson_read_flag flg) {
+                                      yyjson_read_code code) {
     if (cur >= end) return true;
     if (code == YYJSON_READ_ERROR_LITERAL) {
         if (is_truncated_str(cur, end, "true", true) ||
@@ -4368,8 +4356,6 @@ static const f64 f64_pow10_table[] = {
  3. This function (with inline attribute) may generate a lot of instructions.
  */
 static_inline bool read_number(u8 **ptr,
-                               u8 **pre,
-                               yyjson_read_flag flg,
                                yyjson_val *val,
                                const char **msg) {
     
@@ -4504,7 +4471,6 @@ static_inline bool read_number(u8 **ptr,
     if (!digi_is_digit_or_fp(*cur)) {
         /* this number is an integer consisting of 19 digits */
         if (sign && (sig > ((u64)1 << 63))) { /* overflow */
-            if (false) return_raw();
             return_f64(normalized_u64_to_f64(sig));
         }
         return_i64(sig);
@@ -4558,7 +4524,6 @@ digi_intg_more:
                 cur++;
                 /* convert to double if overflow */
                 if (sign) {
-                    if (false) return_raw();
                     return_f64(normalized_u64_to_f64(sig));
                 }
                 return_i64(sig);
@@ -4585,9 +4550,6 @@ digi_frac_more:
     sig += (*cur >= '5'); /* round */
     while (digi_is_digit(*++cur));
     if (!dot_pos) {
-        if (!digi_is_fp(*cur) && false) {
-            return_raw(); /* it's a large integer */
-        }
         dot_pos = cur;
         if (*cur == '.') {
             if (!digi_is_digit(*++cur)) {
@@ -4980,8 +4942,6 @@ digi_finish:
  This function use libc's strtod() to read floating-point number.
  */
 static_inline bool read_number(u8 **ptr,
-                               u8 **pre,
-                               yyjson_read_flag flg,
                                yyjson_val *val,
                                const char **msg) {
     
@@ -5102,9 +5048,6 @@ intg_end:
 read_double:
     /* this number should be read as double */
     while (digi_is_digit(*cur)) cur++;
-    if (!digi_is_fp(*cur) && false) {
-        return_raw(); /* it's a large integer */
-    }
     if (*cur == '.') {
         /* skip fraction part */
         dot = cur;
@@ -5186,7 +5129,6 @@ read_double:
  */
 static_inline bool read_string(u8 **ptr,
                                u8 *lst,
-                               bool inv,
                                yyjson_val *val,
                                const char **msg) {
     /*
@@ -5421,10 +5363,6 @@ skip_utf8:
             uni = byte_load_4(src);
         }
 #endif
-        if (false) {
-            if (!inv) return_err(src, "invalid UTF-8 encoding in string");
-            ++src;
-        }
         goto skip_ascii;
     }
     
@@ -5486,13 +5424,10 @@ copy_escape:
     } else if (likely(*src == '"')) {
         val->tag = ((u64)(dst - cur) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;
         val->uni.str = (const char *)cur;
-        *dst = '\0';
         *end = src + 1;
         return true;
     } else {
-        if (!inv) return_err(src, "unexpected control character in string");
-        if (src >= lst) return_err(src, "unclosed string");
-        *dst++ = *src++;
+        return_err(src, "unexpected control character in string");
     }
     
 copy_ascii:
@@ -5664,10 +5599,6 @@ copy_utf8:
             uni = byte_load_4(src);
         }
 #endif
-        if (false) {
-            if (!inv) return_err(src, "invalid UTF-8 encoding in string");
-            goto copy_ascii_stop_1;
-        }
         goto copy_ascii;
     }
     goto copy_escape;
@@ -5694,11 +5625,10 @@ static_noinline yyjson_doc *read_root_single(u8 *hdr,
                                              u8 *cur,
                                              u8 *end,
                                              yyjson_alc alc,
-                                             yyjson_read_flag flg,
                                              yyjson_read_err *err) {
     
 #define return_err(_pos, _code, _msg) do { \
-    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \
+    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code)) { \
         err->pos = (usize)(end - hdr); \
         err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \
         err->msg = "unexpected end of data"; \
@@ -5776,13 +5694,12 @@ doc_end:
         if (unlikely(cur < end)) goto fail_garbage;
     }
     
-    if (false) **pre = '\0';
     doc = (yyjson_doc *)val_hdr;
     doc->root = val_hdr + hdr_len;
     doc->alc = alc;
     doc->dat_read = (usize)(cur - hdr);
     doc->val_read = 1;
-    doc->str_pool = has_read_flag(INSITU) ? NULL : (char *)hdr;
+    doc->str_pool = (char *)hdr;
     return doc;
     
 fail_string:
@@ -5810,11 +5727,10 @@ static_inline yyjson_doc *read_root_minify(u8 *hdr,
                                            u8 *cur,
                                            u8 *end,
                                            yyjson_alc alc,
-                                           yyjson_read_flag flg,
                                            yyjson_read_err *err) {
     
 #define return_err(_pos, _code, _msg) do { \
-    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \
+    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code)) { \
         err->pos = (usize)(end - hdr); \
         err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \
         err->msg = "unexpected end of data"; \
@@ -5861,8 +5777,6 @@ static_inline yyjson_doc *read_root_minify(u8 *hdr,
     u32 container_depth = 0; /* limit on number of open array and map */
     bool raw; /* read number as raw */
     bool inv; /* allow invalid unicode */
-    u8 *raw_end; /* raw end for null-terminator */
-    u8 **pre; /* previous raw end pointer */
     
     dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);
     hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);
@@ -5877,11 +5791,7 @@ static_inline yyjson_doc *read_root_minify(u8 *hdr,
     val = val_hdr + hdr_len;
     ctn = val;
     ctn_len = 0;
-    raw = has_read_flag(NUMBER_AS_RAW) || false;
-    inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;
-    raw_end = NULL;
-    pre = raw ? &raw_end : NULL;
-    
+
     if (*cur++ == '{') {
         ctn->tag = YYJSON_TYPE_OBJ;
         ctn->uni.ofs = 0;
@@ -6178,7 +6058,6 @@ doc_end:
         if (unlikely(cur < end)) goto fail_garbage;
     }
     
-    if (false) **pre = '\0';
     doc = (yyjson_doc *)val_hdr;
     doc->root = val_hdr + hdr_len;
     doc->alc = alc;
@@ -6215,11 +6094,10 @@ static_inline yyjson_doc *read_root_pretty(u8 *hdr,
                                            u8 *cur,
                                            u8 *end,
                                            yyjson_alc alc,
-                                           yyjson_read_flag flg,
                                            yyjson_read_err *err) {
     
 #define return_err(_pos, _code, _msg) do { \
-    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \
+    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code)) { \
         err->pos = (usize)(end - hdr); \
         err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \
         err->msg = "unexpected end of data"; \
@@ -6264,10 +6142,6 @@ static_inline yyjson_doc *read_root_pretty(u8 *hdr,
     const char *msg; /* error message */
 
     u32 container_depth = 0; /* limit on number of open array and map */
-    bool raw; /* read number as raw */
-    bool inv; /* allow invalid unicode */
-    u8 *raw_end; /* raw end for null-terminator */
-    u8 **pre; /* previous raw end pointer */
     
     dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);
     hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);
@@ -6282,10 +6156,6 @@ static_inline yyjson_doc *read_root_pretty(u8 *hdr,
     val = val_hdr + hdr_len;
     ctn = val;
     ctn_len = 0;
-    raw = has_read_flag(NUMBER_AS_RAW) || false;
-    inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;
-    raw_end = NULL;
-    pre = raw ? &raw_end : NULL;
     
     if (*cur++ == '{') {
         ctn->tag = YYJSON_TYPE_OBJ;
@@ -6588,10 +6427,6 @@ obj_val_end:
         while (char_is_space(*++cur));
         goto obj_val_end;
     }
-    if (false) {
-        if (skip_spaces_and_comments(&cur)) goto obj_val_end;
-        if (byte_match_2(cur, "/*")) goto fail_comment;
-    }
     goto fail_character;
     
 obj_end:
@@ -6624,7 +6459,6 @@ doc_end:
         if (unlikely(cur < end)) goto fail_garbage;
     }
     
-    if (false) **pre = '\0';
     doc = (yyjson_doc *)val_hdr;
     doc->root = val_hdr + hdr_len;
     doc->alc = alc;
@@ -6664,7 +6498,6 @@ fail_recursion:
 
 yyjson_doc *yyjson_read_opts(char *dat,
                              usize len,
-                             yyjson_read_flag flg,
                              const yyjson_alc *alc_ptr,
                              yyjson_read_err *err) {
     
@@ -6675,56 +6508,26 @@ yyjson_doc *yyjson_read_opts(char *dat,
     if (!has_read_flag(INSITU) && hdr) alc.free(alc.ctx, (void *)hdr); \
     return NULL; \
 } while (false)
-    
-
     yyjson_alc alc;
     yyjson_doc *doc;
     u8 *hdr = NULL, *end, *cur;
-    
-    /* validate input parameters */
 
     if (!alc_ptr) {
         alc = YYJSON_DEFAULT_ALC;
     } else {
         alc = *alc_ptr;
     }
-    if (unlikely(!dat)) {
-        return_err(0, INVALID_PARAMETER, "input data is NULL");
-    }
-    if (unlikely(!len)) {
-        return_err(0, INVALID_PARAMETER, "input length is 0");
-    }
-    
-    /* add 4-byte zero padding for input data if necessary */
-    if (has_read_flag(INSITU)) {
-        hdr = (u8 *)dat;
-        end = (u8 *)dat + len;
-        cur = (u8 *)dat;
-    } else {
-        if (unlikely(len >= USIZE_MAX - YYJSON_PADDING_SIZE)) {
-            return_err(0, MEMORY_ALLOCATION, "memory allocation failed");
-        }
-        hdr = (u8 *)alc.malloc(alc.ctx, len + YYJSON_PADDING_SIZE);
-        if (unlikely(!hdr)) {
-            return_err(0, MEMORY_ALLOCATION, "memory allocation failed");
-        }
-        end = hdr + len;
-        cur = hdr;
-        memcpy(hdr, dat, len);
-        memset(end, 0, YYJSON_PADDING_SIZE);
-    }
+
+    hdr = (u8 *)alc.malloc(alc.ctx, len + YYJSON_PADDING_SIZE);
+    end = hdr + len;
+    cur = hdr;
+    memcpy(hdr, dat, len);
+    memset(end, 0, YYJSON_PADDING_SIZE);
     
     /* skip empty contents before json document */
     if (unlikely(char_is_space_or_comment(*cur))) {
-        if (false) {
-            if (!skip_spaces_and_comments(&cur)) {
-                return_err(cur - hdr, INVALID_COMMENT,
-                           "unclosed multiline comment");
-            }
-        } else {
-            if (likely(char_is_space(*cur))) {
-                while (char_is_space(*++cur));
-            }
+        if (likely(char_is_space(*cur))) {
+            while (char_is_space(*++cur));
         }
         if (unlikely(cur >= end)) {
             return_err(0, EMPTY_CONTENT, "input data is empty");
@@ -6734,35 +6537,17 @@ yyjson_doc *yyjson_read_opts(char *dat,
     /* read json document */
     if (likely(char_is_container(*cur))) {
         if (char_is_space(cur[1]) && char_is_space(cur[2])) {
-            doc = read_root_pretty(hdr, cur, end, alc, flg, err);
+            doc = read_root_pretty(hdr, cur, end, alc, err);
         } else {
-            doc = read_root_minify(hdr, cur, end, alc, flg, err);
+            doc = read_root_minify(hdr, cur, end, alc, err);
         }
     } else {
-        doc = read_root_single(hdr, cur, end, alc, flg, err);
+        doc = read_root_single(hdr, cur, end, alc, err);
     }
     
     /* check result */
-    if (likely(doc)) {
-        memset(err, 0, sizeof(yyjson_read_err));
-    } else {
-        /* RFC 8259: JSON text MUST be encoded using UTF-8 */
-        if (err->pos == 0 && err->code != YYJSON_READ_ERROR_MEMORY_ALLOCATION) {
-            if ((hdr[0] == 0xEF && hdr[1] == 0xBB && hdr[2] == 0xBF)) {
-                err->msg = "byte order mark (BOM) is not supported";
-            } else if (len >= 4 &&
-                       ((hdr[0] == 0x00 && hdr[1] == 0x00 &&
-                         hdr[2] == 0xFE && hdr[3] == 0xFF) ||
-                        (hdr[0] == 0xFF && hdr[1] == 0xFE &&
-                         hdr[2] == 0x00 && hdr[3] == 0x00))) {
-                err->msg = "UTF-32 encoding is not supported";
-            } else if (len >= 2 &&
-                       ((hdr[0] == 0xFE && hdr[1] == 0xFF) ||
-                        (hdr[0] == 0xFF && hdr[1] == 0xFE))) {
-                err->msg = "UTF-16 encoding is not supported";
-            }
-        }
-        if (!has_read_flag(INSITU)) alc.free(alc.ctx, (void *)hdr);
+    if (unlikely(!doc)) {
+        alc.free(alc.ctx, (void *)hdr);
     }
     return doc;
     
@@ -6878,7 +6663,7 @@ yyjson_doc *yyjson_read_fp(FILE *file,
     /* read JSON */
     memset((u8 *)buf + file_size, 0, YYJSON_PADDING_SIZE);
     flg |= YYJSON_READ_INSITU;
-    doc = yyjson_read_opts((char *)buf, (usize)file_size, flg, &alc, err);
+    doc = yyjson_read_opts((char *)buf, (usize)file_size, &alc, err);
     if (doc) {
         doc->str_pool = (char *)buf;
         return doc;
diff --git a/include/yyjson/yyjson.h b/include/yyjson/yyjson.h
index c2dcdd6..210449d 100644
--- a/include/yyjson/yyjson.h
+++ b/include/yyjson/yyjson.h
@@ -860,8 +860,6 @@ typedef struct yyjson_read_err {
     the `YYJSON_READ_INSITU` flag.
  @param len The length of JSON data in bytes.
     If this parameter is 0, the function will fail and return NULL.
- @param flg The JSON read options.
-    Multiple options can be combined with `|` operator. 0 means no options.
  @param alc The memory allocator used by JSON reader.
     Pass NULL to use the libc's default allocator.
  @param err A pointer to receive error information.
@@ -871,7 +869,6 @@ typedef struct yyjson_read_err {
  */
 yyjson_api yyjson_doc *yyjson_read_opts(char *dat,
                                         size_t len,
-                                        yyjson_read_flag flg,
                                         const yyjson_alc *alc,
                                         yyjson_read_err *err);
 
@@ -941,7 +938,7 @@ yyjson_api_inline yyjson_doc *yyjson_read(const char *dat,
                                           yyjson_read_flag flg) {
     flg &= ~YYJSON_READ_INSITU; /* const string cannot be modified */
     return yyjson_read_opts((char *)(void *)(size_t)(const void *)dat,
-                            len, flg, NULL, NULL);
+                            len, NULL, NULL);
 }
 
 /**
